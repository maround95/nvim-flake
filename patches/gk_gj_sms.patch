diff --git a/src/nvim/buffer_defs.h b/src/nvim/buffer_defs.h
index 7db9ddc75e..735a565af1 100644
--- a/src/nvim/buffer_defs.h
+++ b/src/nvim/buffer_defs.h
@@ -1246,6 +1246,7 @@ struct window_S {
 
   linenr_T w_botline;               // number of the line below the bottom of
                                     // the window
+  bool w_botline_partial;           // window ends mid-line at the bottom
   int w_empty_rows;                 // number of ~ rows in window
   int w_filler_rows;                // number of filler rows at the end of the
                                     // window
diff --git a/src/nvim/drawscreen.c b/src/nvim/drawscreen.c
index f3919ace58..31a37c8775 100644
--- a/src/nvim/drawscreen.c
+++ b/src/nvim/drawscreen.c
@@ -2599,6 +2599,9 @@ void redraw_later(win_T *wp, int type)
 {
   // curwin may have been set to NULL when exiting
   assert(wp != NULL || exiting);
+  if (type == UPD_INVERTED && wp->w_botline_partial) {
+    type = UPD_NOT_VALID;
+  }
   if (!exiting && !redraw_not_allowed && wp->w_redr_type < type) {
     wp->w_redr_type = type;
     if (type >= UPD_NOT_VALID) {
diff --git a/src/nvim/move.c b/src/nvim/move.c
index 762f6b7d51..0f90eeb0e2 100644
--- a/src/nvim/move.c
+++ b/src/nvim/move.c
@@ -58,6 +58,93 @@ typedef struct {
 
 #include "move.c.generated.h"
 
+/// Compute the cursor's 0-based window row without relying on VALID_WROW/W_CROW.
+/// Intended for use inside update_topline() where cursor screen position may be
+/// invalid, but we must reason about wrapped screenlines.
+///
+/// Preconditions: wp->w_topline/w_topfill/w_skipcol describe the current viewport.
+/// Does NOT call validate_cursor(), curs_columns(), update_topline(), or scroll.
+static int cursor_winrow_novalid(win_T *wp)
+{
+  int row = wp->w_topfill;
+
+  if (wp->w_cursor.lnum < wp->w_topline) {
+    return 0;
+  }
+
+  // Precompute wrap widths once (used for both seg and skipcol math).
+  int width1 = 0;
+  int width2 = 0;
+  if (wp->w_p_wrap && wp->w_p_sms) {
+    width1 = wp->w_view_width - win_col_off(wp);
+    width2 = wp->w_view_width - win_col_off2(wp);
+    if (width1 < 1) {
+      width1 = 1;
+    }
+    if (width2 < 1) {
+      width2 = 1;
+    }
+  }
+
+  // Sum visible screen rows of full buffer lines between topline and cursor line.
+  for (linenr_T lnum = wp->w_topline; lnum < wp->w_cursor.lnum; lnum++) {
+    int h = plines_win_nofill(wp, lnum, true);
+
+    // If the window starts inside the topline (skipcol>0), the topline does
+    // not contribute its full wrapped height to the viewport.
+    if (lnum == wp->w_topline && wp->w_p_wrap && wp->w_p_sms && wp->w_skipcol > 0) {
+      int skip_lines;
+      if (wp->w_skipcol > width1) {
+        skip_lines = 1 + ((wp->w_skipcol - width1) / width2);
+      } else {
+        skip_lines = 1;
+      }
+
+      h -= skip_lines;
+      if (h < 0) {
+        h = 0;
+      }
+    }
+
+    row += h;
+    if (row >= wp->w_view_height + 1) {
+      return row;  // clamp: only care if past bottom
+    }
+  }
+
+  if (!(wp->w_p_wrap && wp->w_p_sms)) {
+    return row;
+  }
+
+  validate_virtcol(wp);
+
+  int v = wp->w_virtcol;
+  int seg;
+  if (v < width1) {
+    seg = 0;
+  } else {
+    v -= width1;
+    seg = 1 + v / width2;
+  }
+
+  // If the cursor is on the topline and we start inside it, hide initial segs.
+  if (wp->w_topline == wp->w_cursor.lnum && wp->w_skipcol > 0) {
+    int skip;
+    if (wp->w_skipcol > width1) {
+      skip = 1 + ((wp->w_skipcol - width1) / width2);
+    } else {
+      skip = 1;
+    }
+
+    seg -= skip;
+    if (seg < 0) {
+      seg = 0;
+    }
+  }
+
+  return row + seg;
+}
+
 /// Get the number of screen lines skipped with "wp->w_skipcol".
 static int adjust_plines_for_skipcol(win_T *wp)
 {
@@ -97,6 +184,8 @@ static void comp_botline(win_T *wp)
   linenr_T lnum;
   int done;
 
+  int old_empty_rows = wp->w_empty_rows;
+
   // If w_cline_row is valid, start there.
   // Otherwise have to start at w_topline.
   check_cursor_moved(wp);
@@ -126,12 +215,34 @@ static void comp_botline(win_T *wp)
     lnum = last;
   }
 
-  // wp->w_botline is the line that is just below the window
-  wp->w_botline = lnum;
-  wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
+  linenr_T bot = lnum;
+  int done_for_empty = done;
+  bool botline_partial = false;
+
+  if (wp->w_p_sms && done < wp->w_view_height && lnum <= wp->w_buffer->b_ml.ml_line_count) {
+    linenr_T last = lnum;
+    bool folded;
+    int n = plines_correct_topline(wp, lnum, &last, true, &folded);
+    if (done + n > wp->w_view_height) {
+      bot = last + 1;
+      done_for_empty = wp->w_view_height;
+      botline_partial = true;
+    }
+  }
+
+  wp->w_botline = bot;
+  wp->w_botline_partial = botline_partial;
+  wp->w_valid |= VALID_BOTLINE | VALID_BOTLINE_AP;
   wp->w_viewport_invalid = true;
 
-  set_empty_rows(wp, done);
+  set_empty_rows(wp, done_for_empty);
+
+  // If we changed the bottom semantics (partial wrapped line) or the number of
+  // empty rows, force a full redraw. This avoids stale attributes on the
+  // bottom-clipped wrapped rows.
+  if (botline_partial || wp->w_empty_rows != old_empty_rows) {
+    redraw_later(wp, UPD_NOT_VALID);
+  }
 
   win_check_anchored_floats(wp);
 }
@@ -534,7 +645,17 @@ void check_cursor_moved(win_T *wp)
              || wp->w_leftcol != wp->w_valid_leftcol
              || wp->w_cursor.coladd !=
              wp->w_valid_cursor.coladd) {
-    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);
+    int invalidate = VALID_WROW | VALID_WCOL | VALID_VIRTCOL;
+
+    // With 'wrap' + 'smoothscroll', changing the cursor column can change which
+    // wrapped screenline the cursor is on, which can require scrolling. Treat
+    // this like a topline-dependent change.
+    if (wp->w_p_wrap && wp->w_p_sms) {
+      invalidate |= VALID_TOPLINE | VALID_BOTLINE | VALID_BOTLINE_AP;
+    }
+
+    wp->w_valid &= ~invalidate;
+
     wp->w_valid_cursor.col = wp->w_cursor.col;
     wp->w_valid_leftcol = wp->w_leftcol;
     wp->w_valid_cursor.coladd = wp->w_cursor.coladd;
@@ -1783,14 +1904,52 @@ void scroll_cursor_top(win_T *wp, int min_scroll, int always)
     off = mouse_dragging - 1;
   }
 
-  // Decrease topline until:
-  // - it has become 1
-  // - (part of) the cursor line is moved off the screen or
-  // - moved at least 'scrolljump' lines and
-  // - at least 'scrolloff' lines above and below the cursor
   validate_cheight(wp);
+  validate_virtcol(wp);
+
   int scrolled = 0;
-  int used = wp->w_cline_height;  // includes filler lines above
+
+  // Cursor line total screen height (includes filler above).
+  int used = wp->w_cline_height;
+
+  // Compute wrap segment index above the cursor (screenline-wise), and the
+  // skipcol that would put the cursor's current segment at the top.
+  int width1 = 0;
+  int width2 = 0;
+  int above = 0;
+  int curseg_skipcol = 0;
+
+  if (wp->w_p_sms && wp->w_p_wrap) {
+    // NOTE: wrapped lines may have different widths for first/continuation
+    // screenlines (number column, showbreak, etc).
+    width1 = wp->w_view_width - win_col_off(wp);
+    width2 = wp->w_view_width - win_col_off2(wp);
+    if (width1 < 1) {
+      width1 = 1;
+    }
+    if (width2 < 1) {
+      width2 = 1;
+    }
+
+    int v = wp->w_virtcol;
+    if (v < width1) {
+      above = 0;
+      curseg_skipcol = 0;
+    } else {
+      v -= width1;
+      above = 1 + v / width2;
+      curseg_skipcol = width1 + (above - 1) * width2;
+    }
+
+    // If we start the window inside the cursor line (skipcol>0), the wrapped
+    // segments above are not shown, so they must not count toward "used".
+    used -= above;
+    if (used < 1) {
+      used = 1;
+    }
+  }
+
+  // If the cursor line is above the window, scrolling definitely happens.
   if (wp->w_cursor.lnum < wp->w_topline) {
     scrolled = used;
   }
@@ -1804,15 +1963,23 @@ void scroll_cursor_top(win_T *wp, int min_scroll, int always)
     top = wp->w_cursor.lnum - 1;
     bot = wp->w_cursor.lnum + 1;
   }
-  linenr_T new_topline = top + 1;
 
-  // "used" already contains the number of filler lines above, don't add it
-  // again.
-  // Hide filler lines above cursor line by adding them to "extra".
+  // Default behavior: aim to put cursor line at top.
+  linenr_T new_topline = wp->w_cursor.lnum;
+  int new_skipcol = 0;
+
+  // Screenlines above the cursor *within the window* (for scrolloff checks).
+  // IMPORTANT: do NOT include "above" here, because if we start inside the
+  // cursor line, those wrapped segments are hidden.
   int extra = win_get_fill(wp, wp->w_cursor.lnum);
 
-  // Check if the lines from "top" to "bot" fit in the window.  If they do,
-  // set new_topline and advance "top" and "bot" to include more lines.
+  if (wp->w_p_sms && wp->w_p_wrap) {
+    new_skipcol = curseg_skipcol;
+  }
+
+  // Check if the lines from "top" to "bot" fit in the window. If they do,
+  // set new_topline/new_skipcol and advance "top" and "bot" to include more
+  // lines. This loop may pull lines above the cursor line to satisfy 'off'.
   while (top > 0) {
     int i = plines_win_nofill(wp, top, true);
     hasFolding(wp, top, &top, NULL);
@@ -1834,48 +2001,61 @@ void scroll_cursor_top(win_T *wp, int min_scroll, int always)
     }
 
     extra += i;
+
+    // If we include a file line above, the cursor can no longer be at the very
+    // top; we're now top-aligned by file line, so skipcol must be zero.
     new_topline = top;
+    new_skipcol = 0;
+
     top--;
     bot++;
   }
 
   // If we don't have enough space, put cursor in the middle.
-  // This makes sure we get the same position when using "k" and "j"
-  // in a small window.
   if (used > wp->w_view_height) {
     scroll_cursor_halfway(wp, false, false);
-  } else {
-    // If "always" is false, only adjust topline to a lower value, higher
-    // value may happen with wrapping lines.
-    if (new_topline < wp->w_topline || always) {
-      wp->w_topline = new_topline;
-    }
-    wp->w_topline = MIN(wp->w_topline, wp->w_cursor.lnum);
-    wp->w_topfill = win_get_fill(wp, wp->w_topline);
-    if (wp->w_topfill > 0 && extra > off) {
-      wp->w_topfill -= extra - off;
-      wp->w_topfill = MAX(wp->w_topfill, 0);
-    }
-    check_topfill(wp, false);
-    if (wp->w_topline != old_topline) {
+    return;
+  }
+
+  // If "always" is false, only adjust topline to a lower value, higher
+  // value may happen with wrapping lines.
+  if (new_topline < wp->w_topline || always) {
+    wp->w_topline = new_topline;
+    wp->w_skipcol = new_skipcol;
+  }
+
+  wp->w_topline = MIN(wp->w_topline, wp->w_cursor.lnum);
+  wp->w_topfill = win_get_fill(wp, wp->w_topline);
+  if (wp->w_topfill > 0 && extra > off) {
+    wp->w_topfill -= extra - off;
+    wp->w_topfill = MAX(wp->w_topfill, 0);
+  }
+  check_topfill(wp, false);
+
+  if (wp->w_topline != old_topline) {
+    // Preserve skipcol when we intentionally start inside the cursor line.
+    if (!(wp->w_p_sms && wp->w_p_wrap && wp->w_topline == wp->w_cursor.lnum)) {
       reset_skipcol(wp);
-    } else if (wp->w_topline == wp->w_cursor.lnum) {
-      validate_virtcol(wp);
-      if (wp->w_skipcol >= wp->w_virtcol) {
-        // TODO(vim): if the line doesn't fit may optimize w_skipcol instead
-        // of making it zero
+    }
+  } else if (wp->w_topline == wp->w_cursor.lnum) {
+    validate_virtcol(wp);
+    // Keep the viewport from starting "past" the cursor.
+    if (wp->w_skipcol > wp->w_virtcol) {
+      if (wp->w_p_sms && wp->w_p_wrap) {
+        wp->w_skipcol = curseg_skipcol;
+      } else {
         reset_skipcol(wp);
       }
     }
-    if (wp->w_topline != old_topline
-        || wp->w_skipcol != old_skipcol
-        || wp->w_topfill != old_topfill) {
-      wp->w_valid &=
-        ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
-    }
-    wp->w_valid |= VALID_TOPLINE;
-    wp->w_viewport_invalid = true;
   }
+
+  if (wp->w_topline != old_topline
+      || wp->w_skipcol != old_skipcol
+      || wp->w_topfill != old_topfill) {
+    wp->w_valid &= ~(VALID_WROW | VALID_CROW | VALID_BOTLINE | VALID_BOTLINE_AP);
+  }
+  wp->w_valid |= VALID_TOPLINE;
+  wp->w_viewport_invalid = true;
 }
 
 // Set w_empty_rows and w_filler_rows for window "wp", having used up "used"
@@ -1965,40 +2145,44 @@ void scroll_cursor_bot(win_T *wp, int min_scroll, bool set_topbot)
   // The lines of the cursor line itself are always used.
   int used = plines_win_nofill(wp, cln, true);
 
+  int dbg_crow = -1;
+  if (wp->w_p_wrap && wp->w_p_sms) {
+    dbg_crow = cursor_winrow_novalid(wp);
+  }
+  (void)dbg_crow;
+
   int scrolled = 0;
   // If the cursor is on or below botline, we will at least scroll by the
   // height of the cursor line, which is "used".  Correct for empty lines,
   // which are really part of botline.
   if (cln >= wp->w_botline) {
-    scrolled = used;
-    if (cln == wp->w_botline) {
-      scrolled -= wp->w_empty_rows;
-    }
     if (do_sms) {
-      // 'smoothscroll' and 'wrap' are set.
-      // Calculate how many screen lines the current top line of window
-      // occupies. If it is occupying more than the entire window, we
-      // need to scroll the additional clipped lines to scroll past the
-      // top line before we can move on to the other lines.
-      int top_plines = plines_win_nofill(wp, wp->w_topline, false);
-      int width1 = wp->w_view_width - win_col_off(wp);
-
-      if (width1 > 0) {
-        int width2 = width1 + win_col_off2(wp);
-        int skip_lines = 0;
-
-        // A similar formula is used in curs_columns().
-        if (wp->w_skipcol > width1) {
-          skip_lines += (wp->w_skipcol - width1) / width2 + 1;
-        } else if (wp->w_skipcol > 0) {
-          skip_lines = 1;
-        }
+      // For 'smoothscroll'+'wrap', don't force scrolling by the full height of the
+      // cursor line; that reveals the whole wrapped line. Instead scroll just
+      // enough screen rows to bring the cursor into view at the bottom (respecting
+      // scrolloff).
+      int so = get_scrolloff_value(wp);
+      if (mouse_dragging > 0) {
+        so = mouse_dragging - 1;
+      }
 
-        top_plines -= skip_lines;
-        if (top_plines > wp->w_view_height) {
-          scrolled += (top_plines - wp->w_view_height);
+      int crow = cursor_winrow_novalid(wp);
+      int bottom = wp->w_view_height - 1 - so - wp->w_empty_rows;
+      int overflow = crow - bottom;
+      scrolled = overflow > 0 ? overflow : 0;
+
+      // Keep the old correction for empty rows when landing exactly on botline.
+      if (cln == wp->w_botline) {
+        scrolled -= wp->w_empty_rows;
+        if (scrolled < 0) {
+          scrolled = 0;
         }
       }
+    } else {
+      scrolled = used;
+      if (cln == wp->w_botline) {
+        scrolled -= wp->w_empty_rows;
+      }
     }
   }
 
